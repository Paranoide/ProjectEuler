package de.michel.projecteuler.problem0012;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import de.michel.projecteuler.util.PrimeGenerator;

/**
 *
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
 * ten terms would be:
 * <pre>
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * </pre> Let us list the factors of the first seven triangle numbers:
 * <pre>
 * 1: 1
 * 3: 1,3
 * 6: 1,2,3,6
 * 10: 1,2,5,10
 * 15: 1,3,5,15
 * 21: 1,3,7,21
 * 28: 1,2,4,7,14,28
 * </pre> We can see that 28 is the first triangle number to have over five
 * divisors.<br/>
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 *
 * @author micmeyer
 */
public class Problem0012
{

    public static void main(String[] args)
    {
        long time = System.currentTimeMillis();

        int n = 1;
        long count = 0;
        long tri = 0;

        while (count < 500)
        {
            tri += n;

            count = countDivisors(tri);

            n++;
        }

        System.out.println(tri);

        System.out.println("Time: " + (System.currentTimeMillis() - time));
    }

    public static long smallGauss(int nth)
    {
        return nth * (nth + 1) / 2;
    }

    public static long countDivisors(long n)
    {
        long count;

        PrimeGenerator pg = new PrimeGenerator();

        List<Long> primes = pg.getPrimeFactors(n);

        Collection<Long> exponents = generatePrimeExponentMap(primes).values();

        count = exponents.stream().mapToLong(Long::longValue).reduce(1, ((a, b) -> a * (b + 1)));

        return count;
    }

    public static Map<Long, Long> generatePrimeExponentMap(List<Long> sortedPrimeFactors)
    {
        Map<Long, Long> map = new HashMap<>();

        Iterator<Long> it = sortedPrimeFactors.iterator();
        long prime, lastPrime = 0;
        long currentPrimeCount = 0;

        if (it.hasNext())
        {
            prime = it.next();
            lastPrime = prime;
            currentPrimeCount = 1;
        }

        while (it.hasNext())
        {
            prime = it.next();

            if (prime > lastPrime)
            {
                map.put(lastPrime, currentPrimeCount);
                lastPrime = prime;
                currentPrimeCount = 1;
            }
            else
            {
                currentPrimeCount++;
            }

        }

        map.put(lastPrime, currentPrimeCount);

        return map;
    }
}
