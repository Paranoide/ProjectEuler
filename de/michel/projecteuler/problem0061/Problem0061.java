package de.michel.projecteuler.problem0061;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
 * are all figurate (polygonal) numbers and are generated by the following
 * formulae:<br/>
 * <br/>
 * <table>
 * <tr>
 * <td valign="top">Triangle:</td>
 * <td valign="top">P<sub>3,n</sub> = n(n+1)/2:</td>
 * <td valign="top">1, 3, 6, 10, 15, ...</td>
 * </tr>
 * <tr>
 * <td>Square:</td>
 * <td>P<sub>4,n</sub> = n<sup>2</sup>:</td>
 * <td>1, 4, 9, 16, 25, ...</td>
 * </tr>
 * <tr>
 * <td valign="top">Pentagonal:</td>
 * <td valign="top">P<sub>5,n</sub> = n(3n−1)/2:</td>
 * <td valign="top">1, 5, 12, 22, 35, ...</td>
 * </tr>
 * <tr>
 * <td valign="top">Hexagonal:</td>
 * <td valign="top">P<sub>6,n</sub> = n(2n−1):</td>
 * <td valign="top">1, 6, 15, 28, 45, ...</td>
 * </tr>
 * <tr>
 * <td valign="top">Heptagonal:</td>
 * <td valign="top">P<sub>7,n</sub> = n(5n−3)/2:</td>
 * <td valign="top">1, 7, 18, 34, 55, ...</td>
 * </tr>
 * <tr>
 * <td valign="top">Octagonal:</td>
 * <td valign="top">P<sub>8,n</sub> = n(3n−2):</td>
 * <td valign="top">1, 8, 21, 40, 65, ...</td>
 * </tr>
 * </table>
 * <br/>
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
 * interesting properties.
 * <ol>
 * <li>The set is cyclic, in that the last two digits of each number is the
 * first
 * two digits of the next number (including the last number with the
 * first).</li>
 * <li>Each polygonal type: triangle (P<sub>3,127</sub>=8128), square
 * (P<sub>4,91</sub>=8281), and
 * pentagonal (P<sub>5,44</sub>=2882), is represented by a different number in
 * the
 * set.</li>
 * <li>This is the only set of 4-digit numbers with this property.</li>
 * </ol>
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which
 * each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
 * octagonal, is represented by a different number in the set.
 *
 * @author micmeyer
 */
public class Problem0061
{

    private static List<List<Integer>> sets;

    public static void main(String[] args)
    {
        long time = System.currentTimeMillis();

        // Create sets and fill them with all 4 digit numbers based
        // on the given formulae
        sets = new ArrayList<>();
        for (int t = 0; t < 6; t++)
        {
            List<Integer> set = new ArrayList<>();
            sets.add(set);

            int f = 0;
            int n = 1;
            while (f < 10000)
            {
                f = f(n, t + 1);
                if (f >= 1000 && f < 10000)
                {
                    set.add(f);
                }
                n++;
            }
        }

        // Store which lists were used and which indices for each list were used
        boolean[] usedLists = new boolean[6];
        int[] usedIndices = new int[6];
        boolean success = false;

        // Start with a number from the first set and try to build up a chain
        // from there
        List<Integer> startSet = sets.get(0);
        usedLists[0] = true;
        for (int t = 0; t < startSet.size() && !success; t++)
        {
            int lastTwoDigits = startSet.get(t) % 100;
            usedIndices[0] = t;
            success = findChain(usedLists, usedIndices, lastTwoDigits);
        }

        int sum = 0;
        for (int t = 0; t < 6; t++)
        {
            sum += sets.get(t).get(usedIndices[t]);
        }

        System.out.println("Sum: " + sum);

        System.out.println();
        System.out.println("Time: " + (System.currentTimeMillis() - time));
    }

    private static boolean findChain(boolean[] usedLists,
            int[] usedIndices,
            int lastTwoDigits)
    {
        if (allTrue(usedLists))
        {
            return (lastTwoDigits == (sets.get(0).get(usedIndices[0]) / 100));
        }

        for (int listIndex = 0; listIndex < 6; listIndex++)
        {
            List<Integer> set;
            if (!usedLists[listIndex])
            {
                set = sets.get(listIndex);
                for (int itemIndex = 0; itemIndex < set.size(); itemIndex++)
                {
                    int f = set.get(itemIndex);
                    int firstTwoDigits = f / 100;
                    if (firstTwoDigits == lastTwoDigits)
                    {
                        if (!contains(usedIndices, itemIndex))
                        {
                            usedLists[listIndex] = true;
                            usedIndices[listIndex] = itemIndex;

                            if (findChain(usedLists, usedIndices, f % 100))
                            {
                                return true;
                            }

                            usedLists[listIndex] = false;
                            usedIndices[listIndex] = -1;
                        }
                    }
                }
            }
        }

        return false;
    }

    private static boolean allTrue(boolean[] bools)
    {
        for (int t = 0; t < bools.length; t++)
        {
            if (!bools[t])
            {
                return false;
            }
        }
        return true;
    }

    private static boolean contains(int[] items, int item)
    {
        for (int t = 0; t < items.length; t++)
        {
            if (items[t] == item)
            {
                return true;
            }
        }
        return false;
    }

    private static int f(int n, int nr)
    {
        switch (nr)
        {
            case 1:
                return f1(n);
            case 2:
                return f2(n);
            case 3:
                return f3(n);
            case 4:
                return f4(n);
            case 5:
                return f5(n);
            case 6:
                return f6(n);
        }
        return 0;
    }

    private static int f1(int n)
    {
        return n * (n + 1) / 2;
    }

    private static int f2(int n)
    {
        return n * n;
    }

    private static int f3(int n)
    {
        return n * (3 * n - 1) / 2;
    }

    private static int f4(int n)
    {
        return n * (2 * n - 1);
    }

    private static int f5(int n)
    {
        return n * (5 * n - 3) / 2;
    }

    private static int f6(int n)
    {
        return n * (3 * n - 2);
    }

}
