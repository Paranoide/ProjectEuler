package de.michel.projecteuler.problems0101_0150.problem0101;

import java.math.BigDecimal;
import java.math.MathContext;
import java.util.List;
import java.util.function.Function;
import java.util.stream.IntStream;

import static java.util.stream.Collectors.toList;

/**
 * If we are presented with the first {@code k} terms of a sequence it is impossible to say with certainty the value of the next term, as there are
 * infinitely many polynomial functions that can model the sequence.
 * <p>
 * <p>
 * As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
 * <p>
 * {@code u}<sub>{@code n}</sub>{@code = n²: 1, 8, 27, 64, 125, 216, ...}
 * <p>
 * Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and
 * predict the next term to be {@code 15} (common difference {@code 7}). Even if we were presented with the first three terms, by the same principle of
 * simplicity, a quadratic relationship should be assumed.
 * <p>
 * We shall define {@code OP(k, n)} to be the {@code n}<sup>{@code th}</sup> term of the optimum polynomial generating function for the first {@code k} terms
 * of a sequence. It should be clear that {@code OP(k, n)} will accurately generate the terms of the sequence for {@code n} &le; {@code k}, and potentially
 * the <i>first incorrect term</i> (FIT) will be {@code OP(k, k+1)}; in which case we shall call it a <i>bad OP</i> (BOP).
 * <p>
 * As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for {@code n} &ge; {@code 2},
 * {@code OP(1, n) = u}<sub>{@code 1}</sub>.
 * <p>
 * Hence we obtain the following {@code OP}s for the cubic sequence:
 * <pre>
 *     OP(1, n) = 1                     1, [1], 1, 1, ...
 *     OP(2, n) = 7n - 6                1, 8, [15], ...
 *     OP(3, n) = 6n² - 11n + 6         1, 8, 27, [58], ...
 *     OP(4, n) = n³                    1, 8, 27, 64, 125, ...
 * </pre>
 * Clearly no BOPs exist for {@code k} &ge; {@code 4}.
 * <p>
 * By considering the sum of FITs generated by the BOPs (indicated in [cornered braces] above), we obtain {@code 1 + 15 + 58 = 74}.
 * <p>
 * Consider the following tenth degree polynomial generating function:
 * <p>
 * {@code u}<sub>{@code n}</sub>{@code = 1 - n + n}
 * <sup>2</sup>{@code - n}<sup>3</sup>{@code + n}<sup>4</sup>{@code - n}
 * <sup>5</sup>{@code + n}<sup>6</sup>{@code - n}<sup>7</sup>{@code + n}
 * <sup>8</sup>{@code - n}<sup>9</sup>{@code + n}<sup>10</sup>
 * <p>
 * Find the sum of FITs for the BOPs.
 */
public class Problem0101
{
    private static final MathContext MATH_CONTEXT = new MathContext(0);

    public static void main(String[] args)
    {
        long time = System.currentTimeMillis();

        String result = executeProblem();

        System.out.println();
        System.out.println("Result: " + result);
        System.out.println();
        System.out.println("Time: " + (System.currentTimeMillis() - time));
    }

    public static String executeProblem()
    {
        long result = 0L;

        Sequence u = new Sequence(Problem0101::u);

        /*
         * 'k' is the 'first k terms of u(n) for which we have to determine the unique polynom'. The polynom will be of (k-1)-th degree.
         *
         * As u(n) is of tenth degree we only need to go from 1 to 10 as with k=11 we would get a polynom of tenth degree and there won't be any differences
         * (the polynom would be exactly u(n)).
         */
        for (int k = 1; k <= 10; k++)
        {
            Sequence polynom = lagrange(k);

            int nAtDifference = findNWhereTheyDiffer(u, polynom);

            result += polynom.get(nAtDifference);
        }

        return String.valueOf(result);
    }

    private static int findNWhereTheyDiffer(Sequence seq1, Sequence seq2)
    {
        for (int n = 1; ; n++)
            if (haveDifferentValue(seq1, seq2, n))
                return n;
    }

    private static boolean haveDifferentValue(Sequence seq1, Sequence seq2, int n)
    {
        return seq1.get(n) != seq2.get(n);
    }

    /**
     * Calculates the value of the tenth degree polynomial function.
     * <br>
     * To avoid {@code long} overflow for n should hold: 1 &le; n &le; 78
     */
    private static long u(int n)
    {
        long result = 0;
        int sign = 1;
        for (int i = 0; i <= 10; i++)
        {
            result += sign * pow(n, i);
            sign = -sign;
        }
        return result;
    }

    private static long pow(int base, int exp)
    {
        long result = 1;
        while (exp-- > 0)
            result *= base;
        return result;
    }

    private static Sequence lagrange(int firstKTermsOfU)
    {
        List<Long> ys = IntStream.range(1, firstKTermsOfU + 1)
                .mapToObj(Problem0101::u)
                .collect(toList());

        return new Sequence(lagrange(ys));
    }

    /**
     * Lagrange Interpolating Polynomial
     */
    private static Function<Integer, Long> lagrange(List<Long> ys)
    {
        return x ->
        {
            BigDecimal x_ = BigDecimal.valueOf(x);

            BigDecimal sum = BigDecimal.ZERO;

            for (int j = 0; j < ys.size(); j++)
            {
                BigDecimal xj = BigDecimal.valueOf(j + 1);
                BigDecimal yj = BigDecimal.valueOf(ys.get(j));

                BigDecimal pjNumerator = BigDecimal.ONE;
                BigDecimal pjDenominator = BigDecimal.ONE;
                for (int k = 0; k < ys.size(); k++)
                {
                    BigDecimal xk = BigDecimal.valueOf(k + 1);

                    if (k != j)
                    {
                        pjNumerator = pjNumerator.multiply(x_.subtract(xk));
                        pjDenominator = pjDenominator.multiply(xj.subtract(xk));
                    }
                }

                sum = sum.add(yj.multiply(pjNumerator).divide(pjDenominator, MATH_CONTEXT));
            }

            return sum.round(MATH_CONTEXT).longValue();
        };
    }

    private static class Sequence
    {
        private final Function<Integer, Long> function;

        public Sequence(Function<Integer, Long> function)
        {
            this.function = function;
        }

        public long get(int n)
        {
            return this.function.apply(n);
        }
    }
}
